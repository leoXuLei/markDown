# HTTP 协议

## HTTP 1.0/1.1/2.0 的区别与联系

HTTP 协议老的标准是 HTTP/1.0，==为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求==。

> **1.0 的缺陷**

- 短暂连接：请求完成即断开，再次请求需要重新慢启动和 TCP 3 次握手。
- `head of line blocking`: 线头阻塞，导致请求之间互相影响

> **1.1 的改进**

- 支持长连接（默认 connection: keep-alive），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
- 增加Host请求头字段后，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
- 还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。
    - cache 缓存
        - Cache-Control
        - Expires
        - Last-Modified
        - Etag
    - 断点续传：1.0不支持文件断点续传，RANGE:bytes是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！

> **2.0的缺陷**

- 多路复用
    在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
- 请求优先级
    多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。
    HTTP 2.0允许给每个request设置优先级。
- 二进制分帧层: 应用层和传输层之间
- 首部压缩
- 服务端推送
    **在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应**。

    Server Push 让 HTTP1.x时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。



> HTTP2.0的多路复用和HTTP1.1中的长连接复用有什么区别？
- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行
